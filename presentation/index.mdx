import { Cite, Notes, Appear } from 'spectacle'

import { DarkSlide, CodeSlide } from './slides'
import { GuessTheType } from './GuessTheType'

## the time and place for

# Implementation Details

---

## Agenda

### Implementation Details

- joke about accent
- elevator pitch
- what are they?
- contrived example
- realistic example
- how to escape them
- when to focus on them

<Notes>... You know what I love?</Notes>

---

talking about implementation details

## ðŸ§¡

<Appear>
  <div>
    <ul>
      <li>Which database? UI Framework? State Management?</li>
      <li>Modal? Hidden inputs? Forcefully open in a new tab?</li>
    </ul>
  </div>
</Appear>

<Notes>
Has APPEAR

... You know what I dislike?

</Notes>

---

being forced to listen to people talk about implentation details

## ðŸ˜‘

<Notes>
Sucks to be you guys I guess!

No, nobody's here against their will, hopefully! What I mean is in meetings, even architecture meetings, you should be reraining from indulging into going too far in the weeds.

... You know what I hate?

</Notes>

---

testing implementation details

## ðŸ¤¬

<Notes>

This is an engineering only pain.

You are an engineer so you want to solve problems.

You want to be confident you've solved them forever and make it easier to improve in the future. So you write tests!

But when you write tests that are too coupled to the implementation details, you sacrifice the "make it easier to improve" part for the confidence it currently works.

</Notes>

---

## Problem

- You solve problems using code
- You want to be confident your code solves them forever
- You want your code to be easy to improve

---

## Solution

- You write tests ðŸŽ‰
- You are confident your code solves the problems it's currently solving forever more âœ…
- But **every time** your tests are **too coupled to implentation details**, you make your code **harder** to improve ðŸ˜±

---

export default CodeSlide

```typescript
const onlineFriends = allUsers
  .filter(({ id }) => user.friendIds.includes(id))
  .filter(({ online }) => online)
```

---

export default CodeSlide

```typescript
const getOnlineFriends = (allUsers: User[]) =>
  allUsers.filter(({ online, id }) => online && user.friendIds.includes(id))
```

---

Error: expected filter to be called twice

---

export default CodeSlide

```typescript
it('only returns online friends', () => {
  const onlineFriends = getOnlineFriends(allUsers)
  expect(Array.prototype.filter).toBeCalledTimes(2) // ðŸ¤ª

  expect(onlineFriends).toEqual([
    // ...
  ])
})
```

<Notes>
  Wait a minute? Has anybody EVER done this? The answer is yes. But this is the
  contrived example.
</Notes>

---

export default CodeSlide

```typescript
const allUsers = knex.select('*').from<User>('users')
const onlineFriends = getOnlineFriends(allUsers)
```

---

export default CodeSlide

```typescript
const onlineFriends = knex
  .select('*')
  .from<User>('users')
  .whereIn('id', user.friendIds)
```

---

Error: `.where` is not a function

---

export default CodeSlide

```typescript
const user = userStore.getUserWithFriends('not-that-talk')
```

---

### What are implementation details?

---

Let's say we've got this design:

---

Even the form is an implementation detail!

---

## Goal: Allow users to pick a username

---

can you tell which uses hooks?

<GuessTheType />

---

> `typeof` doesn't discriminate, why should your tests?

---

There are frameworks that make testing implementation details too easy

---

Enzyme example

---

There are frameworks that help with avoiding implementation details

- Cypress
- Testing Library

---

that promotes good testing practices

---

testing library refactor

---

mocking fetch...

---

GraphQL refactor?

---

testing library render overwrite

---

![datboi](https://pbs.twimg.com/media/CkjFUyTXEAEysBY.jpg)

---

# Thanks!

> "You can do anything, given infinite time"

<Cite>Johnny Magrippis</Cite>
